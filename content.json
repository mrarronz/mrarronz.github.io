[{"title":"Hello World","date":"2017-08-07T06:26:10.000Z","path":"2017/08/07/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Tomcat在mac下的环境配置","date":"2017-03-06T05:36:33.000Z","path":"2017/03/06/2017-03-06-tomcat-config-mac/","text":"##下载tomcat 地址: http://tomcat.apache.org/ 选择左侧Download，根据本机JDK版本选择对应的tomcat版本，下载ZIP包 路径配置1、解压缩zip包，将文件夹名字改为Tomcat，将Tomcat文件夹放入到/Library/路径下 2、打开终端，cd到/Library/Tomcat/bin路径下，输入： 1sudo sh startup.sh 如果出现以下提示则说明安装并运行成功 1234Using CATALINA_BASE: /Library/Tomcat Using CATALINA_HOME: /Library/Tomcat Using CATALINA_TMPDIR: /Library/Tomcat/temp Using JRE_HOME: /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home 在浏览器输入localhost:8080并回车，页面跳转到Apache Tomcat后说明tomcat已成功运行 脚本配置使用文本编辑器输入以下脚本 12345678910111213141516171819#!/bin/bashcase $1 instart)sh /Library/Tomcat/bin/startup.sh;;stop)sh /Library/Tomcat/bin/shutdown.sh;;restart)sh /Library/Tomcat/bin/shutdown.shsh /Library/Tomcat/bin/startup.sh;;*)echo “Usage: start|stop|restart”;;esacexit 0 保存文件名为tomcat，不带后缀。打开终端，cd到tomcat文件所在路径，输入以下命令： 1sudo chmod 777 tomcat 赋予文件可执行权限后，将文件拖放到/usr/local/bin目录下，然后在终端中输入tomcat start，tomcat stop和tomcat restart来使用tomcat了。如果tomcat start等命令执行后出现Permission Denied的情况，需要加上sudo，回车后输入本机登录密码就行了。","tags":[{"name":"WebServer","slug":"WebServer","permalink":"https://mrarronz.github.io/tags/WebServer/"}]},{"title":"Git常用命令和用法","date":"2016-05-27T15:28:26.000Z","path":"2016/05/27/2016-05-27-git-usage/","text":"Git是一个免费开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。svn就是集中式的版本控制系统。 平常用到的git命令主要有： 123456789101112git init // 创建git仓库git clone // 相当于svn的checkout，拉取代码git add // 添加文件或目录到版本管理git status // 查看状态git commit // 提交到仓库git push origin master // 将更新同步到远程仓库git rm 文件名 // 删除文件git pull // 拉取更新，相当于svn updategit push // 将本地仓库的更改push到远程仓库路径git tag // 创建taggit branch // 创建分支git log // 查看提交的log git命令用法一搜一大堆，这里不再赘述了。保留几个常用命令速查手册，便于查找： Git 常用命令速查表(图文+表格) Git常用命令速查表 Git常用命令","tags":[{"name":"Git","slug":"Git","permalink":"https://mrarronz.github.io/tags/Git/"}]},{"title":"SVN命令汇总和基本用法","date":"2016-05-27T14:19:09.000Z","path":"2016/05/27/2016-05-27-svn-command-usage/","text":"本文内容来自于以下文章，著作权属于原作者。本文在原作的基础上加以整理修改而成，仅用于笔记参考学习。 svn常用命令详解（很全，很实用） (转)SVN常用命令用法说明 SVN 主干(trunk)、分支(branch )、标记(tag) Subversion的命令在命令行输入svn help可以查看svn的所有命令 命令用法1、svn add 添加文件或目录到你的working copy(以下简称WC)，打上新增标记A。这些文件会在下一次你提交WC的时候提交到svn服务器. 12svn add test.h (添加一个文件)svn add *.h (添加当前目录下所有.h文件) 2、svn blame(praise, annotate, ann) 显示某个在版本管理下的文件的每一行的最后修改版本和作者 12svn blame test.hsvn blame --xml test.h (加上xml参数可以以xml格式显示每一行的属性) 3、svn cat 不checkout而查看输出特定文件或URL的内容 1234svn cat file.cppsvn cat file.cpp -r 2 (显示版本号为 2 的file.cpp内容)svn cat file.cpp --revision HEAD (显示最新版本的file.cpp内容)svn cat svn://127.0.0.1/test/readme.txt (文件全路径) 4、svn changelist(cl) 可以将WC中的文件从逻辑上分组. changelist CLNAME PATH… changelist –remove PATH… 12svn cl testChangelist file1.h file2.h file3.h (将file1.h等三个文件加入名叫testChangelist的changelist)svn commit --changelist testChangelist -m \"create new changelist\" (将testChangelist下的所有文件提交) 5、svn checkout copy出一份文件 12svn co [svn路径]svn co -r 200 (checkout出版本号为200的项目) 6、svn cleanup 递归的清理WC中过期的锁和未完成的操作。 1svn cleanup 7、svn commit(ci) 将更改提交到仓库 1svn commit -m \"Update file.\" (必须要加上提交的注释) 8、svn copy(cp) copy操作可以从WC到WC；WC到URL；URL到 WC；URL到URL。现在SVN 只支持同一个仓库内文件的拷贝，不允许跨仓库操作。 copy命令是创建分支和标记的常用方式。copy到url的操作隐 含了提交动作，所以需要提供log messages。 1svn copy path1 path2 -m \"This is the commit message\" (path1 和 path2是同一个仓库内的项目路径) 9、svn delete(del, remove, rm) 删除文件 12svn delete file1.h (commit的时候才会将仓库中的file1.h删除)svn delete file://192.168.1.111/svn/file1.h (删除仓库中的文件) 10、svn diff(di) 用来比较并显示修改点 123svn diff (用来显示WC基于最近一次更新以后的所有的本地修改点)svn diff -r 301 bin (比较本地WC和版本301中的bin目录的修改点)svn diff -r 3000:3500 file://var/svn /repos/myProject/trunk (比较库里主干3000版和3500版的差异) 11、svn export 导出一个干净的目录树，不包含所有的版本管理信息。可以选择从URL或WC中导出 1svn export file://var/svn/repos my-export (导出到my-export目录) 12、svn help(?, h) 13、svn import 导入本地一个目录到库中。但是导入后，本地的目录并不会处于版本管理状态 1svn import -m \"message\" path 14、svn info 查看当前WC或目录的信息 15、svn list(ls) 显示目标下的文件和目录列表 1svn ls --verbose path (verbose可以不加，加上是为了显示详细信息) 16、svn lock 对目标获得修改锁。如果目标已被其他用户锁定，则会抛出警告信息。 用–force参数强制从其他用户那里获得锁 1svn lock filename.h 17、svn log 查看仓库修改时的log信息，包括add，modified，delete，replace， merge 12svn logsvn log -r 200 (查看指定版本号的提交log) 18、svn merge 合并两个受控源的不同之处，存放到一个WC里。 12svn merge --reintegrate http://svn .example.com/repos/calc/branches/my-calc-branch (合并分支上的改变项到WC，往往用于分支合并到主干)svn merge -r 156:157 http://svn .example.com/repos/calc/branches/my-calc-branch (将制定URL版本156到157的所有更新合并到WC) 19、svn mergeinfo 查看merge操作的信息 1svn mergeinfo http://svn .example.com/repos/calc/branches/my-calc-branch 20、svn mkdir 在WC或库路径创建目录 1svn mkdir DirectoryName 21、svn move(mv, rename, ren) 等同于svn copy命令跟个svn delete命令。WC到URL的重命名是不被允许的。 1svn move foo.c bar.c (将foo.c改名成bar.c) 22、svn patch svn生成patch和打（导入）patch文件的方法 23、svn propdel (pdel, pd) svn propedit PROPNAME TARGET… propedit PROPNAME –revprop -r REV [TARGET] 从受控文件，目录等删除属性。第二种是删除某个指定版本上的附加属性 1svn propdel svn :mime-type someFile (从someFile上移除svn :mime-type这个属性) 24、svn propedit (pedit, pe) svn propedit PROPNAME TARGET… svn propedit PROPNAME –revprop -r REV [TARGET] 修改属性 1svn propedit svn :keywords file.c (修改file.c上的svn :keywords属性) 25、svn propget (pget, pg) svn propget PROPNAME [TARGET[@REV]…] svn propget PROPNAME –revprop -r REV [URL] 从文件，目录或版本取得指定属性的值 1svn propget svn :keywords file.c (从file.c中取得svn :keywords属性的值) 26、svn proplist (plist, pl) svn proplist [TARGET[@REV]…] svn proplist –revprop -r REV [TARGET] 列出文件、目录或版本上的所有附加属性 1svn proplist --verbose file.c 27、svn propset (pset, ps) 给文件、目录或版本附加属性并赋值 12svn propset svn :mime-type image/jpeg file.jpg (给file.jpg附加属性svn :mime-type 其值为image/jpeg)svn propset --revprop -r 25 svn :log \"Journaled about trip to New York.\" (给版本25补上log message) 28、svn resolve 将冲突的文件标记为已解决，并且删掉冲突产生的临时文件。注意这个命令并不是能把冲突解决，解决冲突还是得靠人工，人工解决冲突后，文件的状态还是冲突C状态，需要将其标记为resolved之后才能正常提交 1svn resolve --accept filePath (filePath是文件路径，1.5版本后，加上--accept参数，尝试自动处理冲突) 29、svn revert 还原WC中所有的本地更改 12svn revert --depth=infinity (将整个目录所有文件还原)svn revert test.h (将对test.h文件所做的修改还原) 30、svn status(stat, st) 输出WC中文件和目录的状态。如果WC提交，这些状态就会同步到仓库里。一般有如下几种状态： ‘’ 没有修改A 新增D 删除M 修改R 替代C 冲突I 忽略？ 未添加到版本管理！ 文件丢失 31、svn switch(sw) svn switch URL，将当前WC切换到另一个URL，一般是从trunk工作目录转向tag工作目录，或者从tag转回来，switch的类似update，将switch的目标工作目录的文件更新到本地，一般会产生很多冲突 svn switch –relocate，将WC连接的服务器地址切换到另一个地址，比如服务器地址由IP地址改为域名的情况，但是项目文件结构都没有变化。 12svn switch pathsvn switch --relocate path1 path2 32、svn unlock 1svn unlock fileName 33、svn update(up) 更新本地WC，直接使用svn up命令，如果要指定版本，使用svn up -r 200 (更新到版本号为200的版本) 34、svn upgrade 如果本地svn版本高于WC当前被管理的svn版本，那么就需要使用upgrade命令将WC的svn版本升级。可以理解为将当前WC所处的环境升级，本来是在1.6版本svn的管理之下，现在通过upgrade之后处于1.7版本的svn管理之下了。 主干、分支和标记通常我们在项目开发中都会建立主干(trunk)、分支(branch )、标记(tag)来管理项目代码。 一般情况下 trunk：是用来做主方向开发的，一个新模块的开发，这个时候就放在trunk，当模块开发完成后，需要修改，就用branch。在开发阶段的代码都提交到该目录上。 branch：是用来做并行开发的，这里的并行是指和trunk进行比较。 tag：是用来做一个milestone的，不管是不是发布版本，但都是一个可用的版本。这里，应该是只读的。更多的是一个显示用的，给人一个可读的标记。 比如，3.0开发完成，这个时候要做一个tag，tag_release_3_0，然后基于这个tag做发布。trunk进入3.1的开发，但是3.0发现了bug，那么就需要基于tag_release_3_0做一个分支(branch)，branch_bugfix_3_0，基于这 个branch进行bug修改，等到bugfix结束，做一个tag，tag_release_3_0_1，然后，根据需要决定 branch_bugfix_3_0是否并入主干(trunk)。 branch和tag的创建都是用svn copy命令完成，将trunk目录下的工程copy到对应的branch和tag目录 1svn cp path1 path2 -m \"create branch\" (path1表示trunk所在路径，path2表示branch或tag路径)","tags":[{"name":"Subversion","slug":"Subversion","permalink":"https://mrarronz.github.io/tags/Subversion/"}]},{"title":"Install jekyll on OS X EI Capitan","date":"2016-05-26T10:30:46.000Z","path":"2016/05/26/2016-05-25-jekyll-install-problem-on-elcapitan/","text":"前不久由于要将Xcode升级到7.3版本，只好将系统升级到OS X最新的EL Capitan。 在安装jekyll的时候出现了问题，这里主要记录下当时的操作，以便以后遇到问题能快速定位，具体错误差不多都忘了。 当执行sudo gem install jekyll命令时总是提示安装不成功，具体错误提示忘记了，大概是: 1234Failed to build gem native extension....ERROR: While executing gem ... (Errno::EPERM)Operation not permitted 然后搜索了半天，结合错误提示，猜测可能是ruby的原因，于是按照各路网友的做法，使用RVM安装ruby。RVM是安装成功了，但是ruby还是安装不成功，mac系统已经自带ruby了，所以用RVM安装ruby个人觉得其实也没必要。直到找到这个Jekyll安装教程之后，又重新试着使用Homebrew来更新ruby。在安装过程中出现问题，按照提示执行brew link xxx(这里都不记得了)，执行之后还是没成功。由于homebrew是我之前安装过的，所以决定将它卸载，重装一遍。 卸载Homebrew，按照以下命令一步步完成 1234567cd `brew --prefix`rm -rf Cellarbrew prunerm `git ls-files`rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributionsrm -rf .gitrm -rf ~/Library/Caches/Homebrew 安装Homebrew 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 这才是正确的方式！ 接着执行以下命令更新ruby 1brew install ruby 1ruby -v ruby成功安装，最新版本是2.3.1p112 然后安装jekyll 1sudo gem install jekyll 顺利安装完成，可以使用命令校验一下 1jekyll -v cd到自己的github page仓库下，执行 1jekyll server 启动成功，在浏览器地址栏输入 1http://127.0.0.1:4000/ （或者localhost:4000） 成功加载出blog主页。","tags":[{"name":"gem","slug":"gem","permalink":"https://mrarronz.github.io/tags/gem/"}]},{"title":"Carthage的安装和使用","date":"2016-05-26T10:30:46.000Z","path":"2016/05/26/2016-05-26-carthage-install-usage/","text":"Carthage是一个去中心化的Cocoa依赖管理器，它与CocoaPods的不同在于： Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断，carthage更加灵活，并且对于我们的项目来说是非侵入性的。我们可以很灵活的管理carthage编译的第三方库。 CocoaPods是把第三方库集中管理，默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace，它修改了我们的项目文件，来达到统一管理第三方库的目的。 CocoaChina上有对carthage的介绍，本文的目的是将carthage的安装和使用等方法统一整理，作为笔记，便于参考记忆。 安装CarthageCarthage可以通过Homebrew来安装，但是直接安装之后出现如下问题。 12345XXX-MacBook-Pro:~ XXX$ brew install carthagecarthage: A full installation of Xcode.app 7.3 is required to compile this software.Installing just the Command Line Tools is not sufficient.Xcode can be installed from the App Store.Error: An unsatisfied requirement failed this build. 我的Xcode版本是7.2，安装carthage必须要使用Xcode最新的版本，仅仅只安装Command line tools是不够的。 App store搜索Xcode 7.3安装，等了半天没反应，软件更新提示里面也没有Xcode。看了Xcode下面的评论才知道原来得先把系统升级到最新的EI Capitan之后才会出现Xcode 7.3版本的更新提示。这个没办法了，网速太渣，系统没法升级。只能下载Carthage官方最新的Release版本了. 下载.pkg文件安装之后，在终端中查看： 12XXX-MacBook-Pro:~ XXX$ carthage version0.16.2 说明安装成功 使用Carthage1、创建Cartfile cd 到项目的根目录下 1touch Cartfile 与CocoaPods的Podfile类似，将第三方库的引用方式写入到Cartfile文件中。以AFNetworking为例 1github \"AFNetworking/AFNetworking\" ~&gt; 3.0 保存Cartfile后，执行 123456789XXX-MacBook-Pro:TestCarthageDemo XXX$ carthage update*** Cloning AFNetworking*** Downloading AFNetworking.framework binary at \"3.1.0\"*** Checking out AFNetworking at \"3.1.0\"*** xcodebuild output can be found in /var/folders/nc/r4zs4js928nd2ty6ng64c7sr0000gp/T/carthage-xcodebuild.nVuUQ1.log*** Building scheme \"AFNetworking OS X\" in AFNetworking.xcworkspace*** Building scheme \"AFNetworking tvOS\" in AFNetworking.xcworkspace*** Building scheme \"AFNetworking watchOS\" in AFNetworking.xcworkspace*** Building scheme \"AFNetworking iOS\" in AFNetworking.xcworkspace 在项目的根目录下会多出Carthage文件夹和Cartfile.resolved文件。 Carthage目录下还有两个文件夹，Build文件夹中存放的是针对各个平台编译好的AFNetworking的framework，Checkouts文件夹中存放的是整个AFNetworking的源代码。 2、在项目中引用framework （1）打开Xcode项目，在项目设置页面General tab中，找到Linked Frameworks and Libraries，将Build文件夹中对应的AFNetworking.framework添加进来。iOS project就选择iOS文件夹下的framework，其它同理。这一步就把framework添加到项目中了，运行项目，build成功，app启动后却发生如下错误 123dyld: Library not loaded: @rpath/AFNetworking.framework/AFNetworkingReferenced from: /Users/XMD001/Library/Developer/CoreSimulator/Devices/1C63D6A2-7EBA-420B-99C4-38C7C1A25911/data/Containers/Bundle/Application/7F3B81EA-9ADF-46DF-9F32-E80F6BED1628/TestCarthageDemo.app/TestCarthageDemoReason: image not found 还有些工作没做完，接着第（2）步~ （2）在Build Phases设置页面，点击左上角的’+’号，新建”New Run Script Phase”，然后将以下脚本粘贴在文本框中： 1/usr/local/bin/carthage copy-frameworks 然后在下面的“Input files”区域将framework的相对路径添加进来： 1$(SRCROOT)/Carthage/Build/iOS/AFNetworking.framework 然后再运行项目，成功了！ 看官方的说明，第（2）步的脚本以work around的形式解决了一个app提交审核时由universal binaries导致的bug。所以这里一定要加上第（2）步的脚本配置。 3、添加framework到Unit Test或framework项目中 由于unit test的General tab中没有Linked Frameworks and Libraries的设置项，framework类型的项目中没有General这个tab，所以必须把carthage编译好的framework添加到Build phase的Link Binaries With Libraries中。在unit test的build settings中找到“Runpath Search Paths”这个选项，如果这一项没有值，那么还需添加以下路径： 1@loader_path/Frameworks 4、更新引用的framework 如果修改了Cartfile（加入了新的framework），或者想要更新现在使用的framework，使用以下命令： 1carthage update 如果只更新某一个framework，可以使用 1carthage update XXX(framework名字) 5、framework之间嵌套依赖 这表示引用的framework之间存在比较多的依赖关系，carthage会自动帮你恢复，framework编译之后需要手动将其添加到项目中 为自己的framework添加Carthage支持1、必须使用Dynamic framework 自己的工程类型必须是Dynamic framework，static library是不行的 2、分享 Xcode scheme Carthage 只构建从 .xcodeproj 分享出来的 Xcode schemes。可以通过运行 carthage build --no-skip-current 来检测所有的 intended schemes 是否构建成功，然后检查 Carthage/Build 文件夹。如果运行命令的时候，一个重要的 scheme 没有构建成功，打开 Xcode 在构建菜单选择 Manage Schemes （如下图） 对于需要构建的 scheme 勾选 Shared （如下图） 示例图片是我的github项目NSStringCategoryKit，也添加了CocoaPods支持。这个项目最初是以static library的方式创建的，后来为了支持carthage，新建了一个framework的target。如果要添加carthage支持，最好还是创建新的framework项目，再来进行carthage的集成。 3、解决构建失败以及打tag 这部分请查看官方文档，说得非常详细了，不再赘述，上面描述的过程都是亲自实践的。 总结通过对CocoaPods和Carthage的使用，两种方式各有优缺点。 CocoaPods会更改项目文件，生成新的.xcworkspace文件，对项目具有侵入性。 Carthage使用比较方便灵活，但是把源代码clone下来就没有必要了吧，导入的项目多了，clone出来Checkouts文件夹里面源代码一堆。 目前来说个人还是用CocoaPods更多一些，完全不用关心怎么设置library的引用，简单方便。","tags":[{"name":"Carthage","slug":"Carthage","permalink":"https://mrarronz.github.io/tags/Carthage/"}]},{"title":"CocoaPods的安装和使用","date":"2016-05-26T10:30:46.000Z","path":"2016/05/26/2016-05-26-cocoapods-install-usage/","text":"安装CocoaPods可以使用Mac自带的RubyGems来安装，但是由于ruby的软件源rubygems.org被天朝屏蔽，只能切换为淘宝的rubygems镜像。 1234XXX-MacBook-Pro:~ XXX$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org/ 移除当前的rubygems，替换为淘宝的 123gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l 可以用以下命令对gem 进行更新： 1sudo gem update --system 然后就可以安装cocoaPods了 1sudo gem install cocoapods Max系统升级到OS X EI Capitan之后改为 12sudo gem install -n /usr/local/bin cocoapodspod setup 使用1、新建Podfile cd到项目的根目录下 1touch Podfile 打开Podfile，在Podfile中引用第三方库 1vim Podfile 12platform :ios, '6.0' pod 'AFNetworking', '~&gt; 3.0' ESC退出编辑，ZZ关闭文件 PS：最近使用cocoaPods时貌似必须要指定target了，如果直接像上述这样写，下载第三方库时会报错，所以改成： 12345platform :ios, '6.0' target 'TargetName' dopod 'AFNetworking', '~&gt; 3.0'end 2、安装第三方库 1pod install 更新时podspec会更新本地仓库，这个过程耗时比较长，可以用以下命令 1pod install --verbose --no-repo-update (注：--verbose可以不加，加上是为了打出更多调试信息) 执行完后，项目根目录下会出现Podfile.lock，pods，后缀名为.xcworkspace的项目文件。以后打开项目就只需要双击xcworkspace文件。 3、更新pod 编辑Podfile文件，加入其它第三方库的引用方式，再执行pod update。在这个过程中需要注意第三方库之间的引用关系，以免造成pod update出错的情况。 1pod update --verbose --no-repo-update 4、多个target的使用方式 推荐方式：不同的target使用不同的第三方依赖配置，如下： 1234567891011source 'https://github.com/CocoaPods/Specs.git'platform :ios, '6.0'target :TargetName1 do pod 'AFNetworking' pod 'MBProgressHUD'endtarget :TargetName2 do pod 'MBProgressHUD'end 创建podspec文件，为自己的项目增加pod支持1、将自己的源码上传到github仓库再clone到本地，如果仓库有代码就直接clone 2、创建podspec文件 cd到项目的根目录，在终端执行以下命令 1pod spec create XXXX(项目名称) 这时候本地仓库就生成了一个podspec文件 3、配置podspec文件 用vim或者编辑器打开.podspec文件进行编辑，以我的项目NSStringCategoryKit为例 1234567891011121314151617Pod::Spec.new do |s| s.name = \"NSStringCategoryKit\" s.version = \"0.0.1\" s.summary = \"A NSString category collections.\" s.description = &lt;&lt;-DESC A category collections for NSString class. All the methods in category are often used in app development. DESC s.homepage = \"https://github.com/mrarronz/NSStringCategoryKit\" s.license = \"MIT\" s.author = &#123; \"mrarronz\" =&gt; \"zhuhao1340@xxx.com\" &#125; s.platform = :ios, \"7.0\" s.source = &#123; :git =&gt; \"https://github.com/mrarronz/NSStringCategoryKit.git\", :tag =&gt; \"0.0.1\" &#125; s.source_files = \"NSStringCategoryKit\"， \"NSStringCategoryKit/**/*.&#123;h，m&#125;\" s.public_header_files = \"NSStringCategoryKit/**/*.h\" s.frameworks = \"Foundation\", \"UIKit\", \"CoreImage\" s.requires_arc = trueend 4、验证podspec文件 在上传podspec文件之前，先验证一下看是否有错误 1pod lib lint 如果出现passed validation的提示，就说明验证通过了，如果出现错误，可以根据错误消息来更改配置文件。 1pod lib lint --verbose 使用以上命令验证时会给出更详细的提示信息，根据这个错误信息来修改配置文件 5、打tag上传podspec文件 12git tag -m \"first release\" \"0.0.1\"git push --tags 注意，这里必须要给项目打上tag，作为一个版本来发布。然后就是把podspec上传到cocoapods官方库了。以前可能需要用clone，pull request的方式提交，耗时非常久，现在只需要参照官方的做法 1pod trunk register orta@cocoapods.org 'Orta Therox' --description='macbook air' 将邮箱，用户名和description改为自己的，执行之后，这个邮箱会收到一封来自cocoaPods官方的邮件，确认之后就注册完成了 然后使用 1pod trunk me 这个命令来查看当前你的账号的会话状况，这个是跟你的设备相关的 cd到你的podspec所在目录，执行以下命令开始提交podspec文件到cocoaPods官方库，这里还是以我的项目为例 1pod trunk push NSStringCategoryKit.podspec 这个过程等待时间比较长，大概一个小时左右，成功之后执行 1pod setup 更新一下本地仓库，再执行 1pod search NSStringCategoryKit 就可以找到项目了。 6、使用自己的pods项目 在Xcode项目的Podfile文件中按照上面的cocoapods的使用方法配置Podfile，例如 12platform:ios, '7.0' pod 'NSStringCategoryKit' 然后执行更新操作就可以了。 如果没有将自己的podspec文件上传，也可以在项目中进行使用，这时需要指定github的项目路径和tag 12platform :ios, '7.0'pod 'NSStringCategoryKit', :git =&gt; 'https://github.com/mrarronz/NSStringCategoryKit.git', :tag =&gt; '0.1.0'","tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://mrarronz.github.io/tags/CocoaPods/"}]}]